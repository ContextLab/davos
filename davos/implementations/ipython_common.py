"""
This modules contains implementations of helper functions common across
all IPython versions and front-end interfaces.
"""


import textwrap
import sys
from contextlib import redirect_stdout
from io import StringIO
from subprocess import CalledProcessError

from IPython.core.error import UsageError
from IPython.core.interactiveshell import system as _run_shell_cmd

from davos import config
from davos.core.exceptions import DavosParserError


def _check_conda_avail_helper():
    """
    Check whether the `conda` executable is available.

    Tries to access the `conda` executable by running `conda list
    IPython` using the `%conda` IPython line magic. If successful,
    return the (suppressed) stdout generated by the command. Otherwise,
    return `None`.

    Returns
    -------
    str or None
        If the `%conda` line magic is available and `conda list IPython`
        runs successfully, the captured stdout. Otherwise, `None`.
    """
    try:
        with redirect_stdout(StringIO()) as conda_list_output:
            # this specific line magic seems to be the only reliable way
            # to *actually* get the kernel environment -- shell (!)
            # commands and all conda magic (%) commands other than
            # `conda list` run in the base conda environment. Listed
            # package is arbitrary, but listing single package is much
            # faster than listing all, so using IPython because it's
            # guaranteed to be installed
            config._ipython_shell.run_line_magic('conda', 'list IPython')
    except (UsageError, ValueError):
        # %conda line magic is not available
        return None
    return conda_list_output.getvalue()


def _run_shell_command_helper(command):
    # much simpler than plain Python equivalent because IPython has a
    # built-in utility function for running shell commands that handles
    # pretty much everything we need it to, and also formats outputs
    # nicely in the notebook
    retcode = _run_shell_cmd(command)
    if retcode != 0:
        raise CalledProcessError(returncode=retcode, cmd=command)


def _set_custom_showsyntaxerror():
    """
    Overload the `IPython` shell's `.showsyntaxerror()` method.

    Replaces the global `IPython` interactive shell object's
    `.showsyntaxerror()` method with a custom function that allows
    `davos`-native exceptions raised during the pre-execution cell
    parsing phase to display a full traceback. Also:
        - updates the custom function's docstring to include the
          original `.showsyntaxerror()` method's docstring and
          explicitly note that the method was updated by `davos`
        - stores a reference to the original `.showsyntaxerror()` method
          in the `davos.config` object so it can be called from the
          custom version
        - binds the custom function to the interactive shell object
          *instance* so it implicitly receives the instance as its first
          argument when called (like a normal instance method)

    See Also
    -------
    IPython.core.interactiveshell.InteractiveShell.showsyntaxerror :
        The original, overloaded `.showsyntaxerror()` method.
    davos.implementations.ipython_common._showsyntaxerror_davos :
        The custom `.showsyntaxerror()` method set by `davos`.

    Notes
    -----
    Runs exactly once when `davos` is imported and initialized in an
    `IPython` environment, and takes no action if run again. This
    prevents overwriting the reference to the original
    `.showsyntaxerror()` method stored in the `davos.config` object.
    """
    if config._ipy_showsyntaxerror_orig is not None:
        # function has already been called
        return

    ipy_shell = config.ipython_shell
    new_doc = textwrap.dedent(f"""\
        {' METHOD UPDATED BY DAVOS PACKAGE '.center(72, '=')}
        
        {textwrap.indent(_showsyntaxerror_davos.__doc__, '    ')}

        {' ORIGINAL DOCSTRING: '.center(72, '=')}
        
        
        {ipy_shell.showsyntaxerror.__doc__}""")

    _showsyntaxerror_davos.__doc__ = new_doc
    config._ipy_showsyntaxerror_orig = ipy_shell.showsyntaxerror
    ipy_shell.showsyntaxerror = _showsyntaxerror_davos.__get__(ipy_shell)


# noinspection PyUnusedLocal
def _showsyntaxerror_davos(
        ipy_shell,
        filename=None,
        running_compiled_code=False
):
    """
    Show `davos` library `SyntaxError` subclasses with full tracebacks.


    Replaces global IPython interactive shell object's
    `.showsyntaxerror()` method during initialization as a way to hook
    into `IPython`'s exception handling machinery for errors raised
    during the pre-execution cell parsing phase.

    Because cell content is parsed as text rather than actually executed
    during this stage, the only exceptions `IPython` expects input
    transformers (such as the `davos` parser) to raise are
    `SyntaxError`s. Thus, all `davos` library exceptions that may be
    raised by the parser inherit from `SyntaxError`). And because
    `IPython` assumes any `SyntaxError`s raised during parsing were
    caused by issues with the cell content itself, it expects their
    stack traces to comprise only a single frame, and displays them in a
    format that does not include a full traceback. This function
    excludes `davos` library errors from this behavior, and displays
    them in full using the standard, more readable & informative format.

    Parameters
    ----------
    ipy_shell : IPython.core.interactiveshell.InteractiveShell
        The global `IPython` shell instance. Because the function is
        bound as a method of the shell instance, this is passed
        implicitly (i.e., equivalent to `self`).
    filename : str, optional
        The name of the file the `SyntaxError` occurred in. If `None`
        (default), the name of the cell's entry in `linecache.cache`
        will be used.
    running_compiled_code : bool, optional
        Whether the `SyntaxError` occurred while running compiled code
        (see **Notes** below).

    See Also
    --------
    IPython.core.interactiveshell.InteractiveShell.showsyntaxerror :
        The original `.showsyntaxerror()` method this function replaces.
    davos.implementations.ipython_common._set_custom_showsyntaxerror :
        Replaces the `.showsyntaxerror()` method with this function/

    Notes
    -----
    The `running_compiled_code` argument was added in `IPython` 6.1.0,
    and setting it to `True` accomplishes (something close to) the same
    thing this workaround does. However, since `davos` needs to support
    `IPython` versions back to v5.5.0 (which is used by Colab), we can't
    rely on it being available.
    """
    etype, value, tb = ipy_shell._get_exc_info()
    if issubclass(etype, DavosParserError):
        try:
            # noinspection PyBroadException
            try:
                stb = value._render_traceback_()
            except:
                stb = ipy_shell.InteractiveTB.structured_traceback(
                    etype, value, tb, tb_offset=ipy_shell.InteractiveTB.tb_offset
                )
            ipy_shell._showtraceback(etype, value, stb)
            if ipy_shell.call_pdb:
                ipy_shell.debugger(force=True)
            return
        except KeyboardInterrupt:
            print('\n' + ipy_shell.get_exception_only(), file=sys.stderr)
    else:
        # original method is stored in Davos instance, but still bound
        # IPython.core.interactiveshell.InteractiveShell instance
        return config._ipy_showsyntaxerror_orig(filename=filename)
