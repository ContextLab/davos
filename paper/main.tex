\documentclass[preprint,12pt,a4paper]{elsarticle}
\usepackage{amssymb}
\usepackage{lineno}
\usepackage{float}
\restylefloat{table}
\usepackage[colorlinks=true, urlcolor=blue, pdfborder={0 0 0}]{hyperref}
\usepackage{breakurl}
\usepackage{placeins}
\usepackage{geometry}
\geometry{left=1in,right=1in,top=1in,bottom=1in,headsep=0pt}

\journal{SoftwareX}

\begin{document}
\begin{frontmatter}

\title{\texttt{davos}: a Python package ``smuggler'' for constructing
  lightweight reproducible notebooks}
\author{Paxton C. Fitzpatrick}
\author{Jeremy R. Manning\corref{cor}}
\ead{Jeremy.R.Manning@Dartmouth.edu}
\cortext[cor]{Corresponding author}
\address{Department of Psychological and Brain Sciences\\Dartmouth College, Hanover, NH 03755}


\begin{abstract}
  Reproducibility is a core requirement of modern scientific research.
  For computational research, reproducibility means that code should
  produce the same results, even when run on different systems.  A
  standard approach to ensuring reproducibility entails packaging a
  project's dependencies along with its primary code base.  Existing
  solutions vary in how deeply these dependencies are specified,
  ranging from virtual environments, to containers, to virtual
  machines.  Each of these existing solutions requires installing or
  setting up a system for running the desired code, increasing the
  complexity and time cost of sharing or engaging with reproducible
  science. Here, we propose a lighter-weight solution: the
  \texttt{davos} package.  When used in combination with a
  notebook-based Python project, \texttt{davos} provides a mechanism
  for specifying (and automatically installing) the correct versions
  of the project's dependencies.  The \texttt{davos} package further
  ensures that those packages and specific versions are used every
  time the notebook's code is executed.  This enables researchers to
  share a complete reproducible copy of their code within a single
  Jupyter notebook file.
\end{abstract}


\begin{keyword}
  Reproducibility \sep Open science \sep Python \sep Jupyter Notebook
  \sep Google Colaboratory \sep Package management
\end{keyword}

\end{frontmatter}


\section*{Metadata}

\section*{Current code version}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} & \textbf{Metadata value} \\
\hline
C1 & Current code version &  v0.1.1 \\
\hline
C2 & Permanent link to code/repository used for this code version & \url{https://github.com/ContextLab/davos/tree/v0.1.1} \\
\hline
C3 & Code Ocean compute capsule & \\
\hline
C4 & Legal Code License & MIT \\
\hline
C5 & Code versioning system used & git \\
\hline
C6 & Software code languages, tools, and services used & Python, JavaScript, PyPI/pip, IPython, Jupyter, Ipykernel, PyZMQ. Additional tools used for tests: pytest, Selenium, Requests, mypy, GitHub Actions \\
\hline
C7 & Compilation requirements, operating environments, and
     dependencies & Dependencies:~Python $\geq 3.6$, packaging, setuptools.~Supported OSes: MacOS, Linux, Unix-like.~Supported IPython environments: Jupyter notebooks, JupyterLab, Google Colaboratory, Binder, IDE-based notebook editors. \\
\hline
C8 & Link to developer documentation/manual & \url{https://github.com/ContextLab/davos\#readme} \\
\hline
C9 & Support email for questions & contextualdynamics@gmail.com \\
\hline
\end{tabular}
\caption{Code metadata}
\label{}
\end{table}

\linenumbers

\section{Motivation and significance}

The same computer code may not behave identically under different
circumstances.  For example, when code depends on external packages,
different versions of those packages may function differently.  Or
when CPU or GPU instruction sets differ across machines, the same
high-level code may be compiled into different machine instructions.
Because executing identical code does not guarantee identical
outcomes, code sharing alone is often insufficient for enabling
researchers to reproduce each other's work, or to collaborate on
projects involving data collection or analysis.

Within the Python~\cite{vanR95} community, external packages that are
published in the most popular repositories~\cite{Pyth03, cond15} are
associated with version numbers and tags that allow users to guarantee
they are installing exactly the same code across different computing
environments~\cite{CoghStuf13}.  While it is \textit{possible} to
manually install the intended version of every dependency of a Python
script or package, manually tracking down those dependencies can
impose a substantial burden on the user and create room for mistakes
and inconsistencies. Further, when dependency versions are left
unspecified, replicating the original computing environment becomes
difficult or impossible.

\begin{figure}[tp]
\centering
\includegraphics[width=\textwidth]{figs/shareable_code}
\caption{\small \textbf{Systems for sharing code within the Python
    ecosystem.}  From left to right: plain-text \textbf{Python
    scripts} (\texttt{.py} files) provide the most basic ``system''
  for sharing raw code.  Scripts may reference external packages, but
  those packages must be manually installed on other users' systems.
  Further, any checking needed to verify that the correct versions of
  those packages were installed must also be performed manually.
  \textbf{Jupyter notebooks} (\texttt{.ipynb} files) comprise embedded
  text, executable code, and media (including rendered figures, code
  output, etc.).  When the \textbf{\texttt{davos} package} is imported
  into a Jupyter notebook, the notebook's functionality is extended to
  automatically install any required external packages (at their
  correct versions, when specified).  \textbf{Virtual environments}
  allow users to install an isolated copy of Python and all required
  dependencies. This typically entails distributing a configuration
  file (e.g., a \texttt{pyproject.toml}~\cite{CannEtal16} or
  \texttt{environment.yml} file) that specifies all project
  dependencies (including version numbers of external packages)
  alongside the primary code base. Users can then install a
  third-party tool~\cite[e.g.,][]{Anac12, Eust19} to read the file and
  build the environment.  \textbf{Containers} provide a means of
  defining an isolated environment that includes a complete operating
  system (independent of the user's operating system), in addition to
  (optionally) specifying a virtual environment or other
  configurations needed to provide the necessary computing
  environment.  Containers are typically defined using specification
  files (e.g., a plain-text \texttt{Dockerfile}) that instruct the
  virtualization engine regarding how to build the containerized
  environment.  \textbf{Virtual machines} provide a complete
  hardware-level simulation of the computing environment.  In addition
  to simulating specific hardware, virtual machines (typically
  specified using binary image files) must also define operating
  system-level properties of the computing environment.  Systems to
  the left of the blue vertical line entail sharing individual files,
  with no additional installation or configuration needed to run the
  target code.  Systems to the right of the red vertical line support
  precise control over dependencies and versioning.  Notebooks
  enhanced using the \texttt{davos} package are easily shareable and
  require minimal setup costs, while also facilitating high
  reproducibility by enabling precise control over project
  dependencies.}
\label{fig:code-sharing}
\end{figure}

Computational researchers and other programmers have de\-vel\-oped a
broad set of approaches and tools to facilitate code sharing and
reproducible outcomes (Fig.~\ref{fig:code-sharing}). At one extreme,
simply distributing a set of Python scripts (\texttt{.py} files) may
enable others to use or gain insights into the relevant work. Because
Python is installed by default on most modern operating systems, for
some projects, this may be sufficient. Another popular approach
entails creating Jupyter notebooks~\cite{KluyEtal16} that comprise a
mix of text, executable code, and embedded media. Notebooks may call
or import external scripts or packages---or even intersperse snippets
of other programming or markup lang\-uages---in order to provide a
more compact and readable experience for users. Both of these systems
(Python scripts and notebooks) provide a convenient means of sharing
code, with the caveat that they do not specify the computing
environment in which the code is executed. Therefore the functionality
of code shared using these systems cannot be guaranteed across
different users or setups.

At another extreme, virtual machines~\cite{Gold74, AltiEtal05, Rose99}
provide a hardware-level simulation of the desired system.  Virtual
machines are typically isolated, such that installing or running
software on a virtual machine does not impact the user's primary
operating system or computing environment.
Containers~\cite[e.g.,][]{Merk14, KurtEtal17} provide a similar
``isolated'' experience. Although containerized environments do not
specify hardware-level operations, they are typically packaged with a
complete operating system, in addition to a complete copy of Python
and any relevant package dependencies. Virtual
environments~\cite[e.g.,][]{Anac12, Eust19} also provide a computing
environment that is largely separated from the user's main
environment. They incorporate a copy of Python and the target
software's dependencies, but virtual environments do not specify or
reproduce an operating system for the runtime environment. Each of
these systems (virtual machines, containers, and virtual environments)
guarantees (to differing degrees---at the hardware level, operating
system level, and Python environment level, respectively) that the
relevant code will run similarly for different users. However, each of
these systems also relies on additional software that can be complex
or resource-intensive to install and use, creating potential barriers
to both contributing to and taking advantage of open science
resources.

We designed \texttt{davos} to occupy a ``sweet spot'' between these
extremes.  \texttt{davos} is a notebook-installable package that adds
functionality to the default notebook experience. Like standard
Jupyter notebooks, \texttt{davos}-enhanced notebooks allow researchers
to include text, executable code, and media within a single file. No
further setup or installation is required, beyond what is needed to
run standard Jupyter notebooks. And like virtual environments,
\texttt{davos} provides a convenient mechanism for fully specifying
(and installing, as needed) a complete set of Python dependencies,
including specific package versions.


\section{Software description}

The \texttt{davos} package is named after Davos Seaworth, a smuggler
referred to as ``the Onion Knight" from the series \textit{A Song of
  Ice and Fire} by George R. R. Martin~\cite{Mart98}.  The
\texttt{smuggle} keyword provided by \texttt{davos}
is a play on Python's \texttt{import} keyword: whereas importing can
load a package into the Python workspace within the existing rules
and frameworks provided by the Python language, ``smuggling'' provides
an alternative that expands the scope and reach of ``importing.''
Like the character Davos Seaworth (who became famous for smuggling
onions through a blockade on his homeland), we use ``onion'' comments
to precisely control how packages are smuggled into the Python
workspace.

\begin{figure}[tp]
\centering
\includegraphics[width=\textwidth]{figs/package_structure}
\caption{\small \textbf{Package structure.} The \texttt{davos} package
  comprises two interdependent subpackages.  The \texttt{davos.core}
  subpackage includes modules for parsing \texttt{smuggle} statements
  and onion comments, installing and validating packages, and
  configuring \texttt{davos}'s behavior.  The
  \texttt{davos.implementations} subpackage includes
  environment-specific modifications and features that are needed to
  support the core functionality across different notebook-based
  environments.  Individual modules (i.e., \texttt{.py} files) are represented by lime
  rounded rectangles, and arrows denote dependencies (each arrow
  points to a module that imports objects defined in the module at the
  arrow's source).}
\label{fig:package-structure}
\end{figure}

\subsection{Software architecture}

The \texttt{davos} package consists of two interdependent subpackages
(see Fig.~\ref{fig:package-structure}). The first,
\texttt{davos.core}, comprises a set of modules that
implement the bulk of the package's core
functionality, including pipelines for installing and validating
packages, custom parsers for the \texttt{smuggle} statement (see
Sec.~\ref{subsec:smuggle}) and onion comment (see
Sec.~\ref{subsec:onion}), and a runtime interface for configuring
\texttt{davos}'s behavior (see Sec.~\ref{subsec:config}). However,
certain critical aspects of this
functionality require (often substantially) different implementations
depending on properties of the notebook environment in which
\texttt{davos} is used (e.g., whether the frontend is provided by
Jupyter or Google Colaboratory, or which version of
IPython~\cite{PereGran07} is used by the notebook kernel). To deal
with this, environment-dependent parts of core features and behaviors
are isolated and abstracted to ``helper functions'' in the
\texttt{davos.implementations} subpackage. This second subpackage
defines multiple, interchangeable versions of each helper function,
organized into modules by the conditions that trigger their use. At
runtime, \texttt{davos} detects various features in the notebook
environment and selectively imports a single version of each helper
function into the top-level \texttt{davos.implementations} namespace,
allowing \texttt{davos.core} modules to access the proper
implementations for the current notebook environment in a single,
consistent location. An additional benefit of this design is that it
allows maintainers, developers, and users to extend \texttt{davos} to
support new, updated, or custom notebook variants by creating new
\texttt{davos.implementations} modules that define their own versions
of each helper function, modified from existing implementations as
needed.

\subsection{Software functionalities}

\subsubsection{The \texttt{smuggle} statement}\label{subsec:smuggle}

Functionally, importing \texttt{davos} in an IPython notebook enables
an additional Python keyword: ``\texttt{smuggle}'' (see
Sec.~\ref{subsec:implementation} for details on how this works).
The \texttt{smuggle} keyword-like object can be used as a drop-in
replacement for Python's built-in \texttt{import} keyword to load
packages, modules, and other objects into the current namespace.
However, whereas \texttt{import} will fail if the requested package is
not installed locally, \texttt{smuggle} statements can handle missing
packages on the fly.  If a smuggled package does not exist in the
local environment, \texttt{davos} will download and install it automatically,
expose its contents to Python's \texttt{import} machinery, and load it
into the namespace for immediate use.

\subsubsection{The onion comment}\label{subsec:onion}

For greater control over the behavior of \texttt{smuggle} statements,
\texttt{davos} defines an additional construct called the ``onion
comment.'' An onion comment is a special type of inline comment that
may be placed on a line containing a \texttt{smuggle} statement to
customize how \texttt{davos} searches for the smuggled package locally
and, if necessary, downloads and installs it. Onion comments follow a
simple format based on the ``type comment'' syntax introduced in PEP
484~\cite{vanREtal14}, and are designed to make managing packages with
\texttt{davos} intuitive and familiar. To construct an onion comment,
users provide the name of the installer program (e.g., \texttt{pip})
and the same arguments one would use to manually install the package
as desired via the command line:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet1}
\end{center}
Occasionally, a package's distribution name (i.e., the name used when
installing it) may differ from its top-level module name (i.e., the
name used when importing it). In such cases, an onion comment may be
used to ensure that \texttt{davos} installs the proper package if it
cannot be found locally:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet2}
\end{center}
Because onion comments may be constructed to specify any aspect of the
installer's behavior, they provide a mechanism for precisely
controlling how, where, and when smuggled packages are installed.
Critically, if an onion comment includes a version
specifier~\cite{CoghStuf13}, \texttt{davos} will ensure that the
version of the package loaded into the notebook matches the specific
version requested, or satisfies the given version constraints. If the
smuggled package exists locally, \texttt{davos} will extract its
version information from its metadata and compare it to the specifier
provided. If the two are incompatible (or no local installation is
found), \texttt{davos} will download, install, and load a suitable
version of the package instead:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet3}
\end{center}
Onion comments can also be used to smuggle specific VCS references
(e.g., Git~\cite{TorvHama05} branches, commits, tags, etc.):
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet4}
\end{center}
\texttt{davos} processes onion comments internally before forwarding
arguments to the installer program. In addition to preventing onion
comments from being used as a vehicle for shell injection attacks,
this enables \texttt{davos} to adapt its behavior based on how particular
flags will affect the behavior of the installer program. For example, if an
onion comment contains either the \texttt{-I}/\texttt{--ignore-installed},
\texttt{-U}/\texttt{--upgrade}, or \texttt{--force-reinstall} flag,
\texttt{davos} will not bother checking for a local copy of the smuggled
package before installing a new one:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet5}
\end{center}
Similarly, the \texttt{--no-input} flag will temporarily enable
\texttt{davos}'s non-interactive mode (see
Sec.~\ref{subsec:config}), and installing a smuggled package into a
custom directory (\texttt{<dir>}) using the \texttt{--target <dir>}
flag will cause \texttt{davos} to prepend \texttt{<dir>} to the module
search path (i.e., \texttt{sys.path}), if necessary, so the package
can be imported.

\subsubsection{The \texttt{davos} config object}\label{subsec:config}

The \texttt{davos} config object provides a high-level interface for
controlling various aspects of \texttt{davos}'s behavior. After
importing \texttt{davos}, the \texttt{davos.con\-fig} object (a
singleton) exposes configurable options as attributes that can be
modified, displayed in the notebook, or checked programmatically at runtime 
(see Sec.~\ref{sec:illustrative-example} for an illustrative example or
Sec.~\ref{subsec:implementation} for implementation details and
additional information). These include:

\begin{itemize}
\item \texttt{.active}: This attribute controls whether support for \texttt{smuggle}
  statements and onion comments) is enabled (\texttt{True}) or
  disabled (\texttt{False}).  When \texttt{davos} is first imported),
  the \texttt{.active} attribute is set to \texttt{True}.
  
\item \texttt{.auto\_rerun}: This attribute controls how
  \texttt{davos} behaves when attempting to \texttt{smuggle} a new
  version of a package that was previously imported and cannot be
  reloaded. This can happen if the package includes extension modules
  that dynamically link C or C++ objects to the Python interpreter,
  and the code that generates those objects was changed between the
  previously imported and to-be-smuggled versions.  If this attribute
  is set to \texttt{True}, \texttt{davos} will automatically restart
  the notebook kernel and rerun all code up to (and including) the
  current \texttt{smuggle} statement. If \texttt{False} (the default),
  \texttt{davos} will instead issue a warning, pause execution, and
  prompt the user to either restart and rerun the notebook, or
  continue running with the previously imported package version until
  the next time the kernel is restarted manually.  Note that, as of
  this writing, the \texttt{.auto\_rerun} attribute is not supported
  in Google Colaboratory notebooks.
  
\item \texttt{.confirm\_install}: If \texttt{True} (default:
  \texttt{False}), \texttt{davos} will require user confirmation
  before installing a smuggled package that does not yet exist in the
  user's environment.
 
\item \texttt{.noninteractive}: Setting this attribute to
  \texttt{True} (default: \texttt{False}) enables non-in\-ter\-act\-ive
  mode, in which all user interactions (prompts and dialogues) are
  disabled. Note that in non-interactive mode, the
  \texttt{confirm\_install} option is set to \texttt{False}.  If
  \texttt{auto\_rerun} is \texttt{False} while in non-interactive
  mode, \texttt{davos} will raise an exception if a smuggled package
  cannot be reloaded, rather than prompting the user.
  
\item \texttt{.pip\_executable}: This attribute's value specifies the
  path to the \texttt{pip} executable used to install smuggled
  packages. The default is programmatically determined from the Python
  environment and falls back to \texttt{sys.executable -m pip} if no
  executable can be found.
  
\item \texttt{.suppress\_stdout}: If this attribute is set to
  \texttt{True} (default: \texttt{False}), \texttt{davos} suppresses
  printed (console) outputs from both itself and the installer program.
  This can be useful when smuggling packages that need to install many
  dependencies and/or generate extensive output. However, if the installer
  program throws an error, both its stdout and stderr streams will be
  displayed alongside the Python traceback to allow for debugging.
\end{itemize}

\noindent The top-level \texttt{davos} namespace also defines
convenience functions for setting and checking whether \texttt{davos}
is active (\texttt{davos.activate()}; \texttt{davos.deactivate()};
\texttt{davos.is\_active()}) as well as the \texttt{davos.configure()}
function, which allows setting multiple configuration options
simultaneously.

\subsection{Implementation details}\label{subsec:implementation}

Although \texttt{davos} is designed to \textit{appear} to add a new
keyword to Python's vocabulary, this illusion is actually created through
several ``hacks'' that make use of the notebook's IPython backend
for processing and executing users' code.  Specifically, when
\texttt{davos} is first imported, or when it is activated after having been
set to an inactive state, two actions are triggered:  First, the
\texttt{smuggle()} function is injected into the IPython user
namespace.  Second, the \texttt{davos} parser is registered as a
custom IPython input transformer.

IPython preprocesses all executed code as plain text before it is sent
to the Python compiler, in order to handle special constructs like
\texttt{\%magic} and \texttt{!shell} commands. \texttt{davos} uses
this process to transform \texttt{smuggle} statements into
syntactically valid Python code. The \texttt{davos} parser uses a
regular expression to match lines of code containing \texttt{smuggle}
statements (and, optionally, onion comments), extract relevant
information from their text, and replace them with equivalent calls to
the \texttt{smuggle()} function. For example, if a user runs a
notebook cell containing
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet6}
\end{center}
the code that is actually executed by the Python interpreter would be
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/snippet7}
\end{center}
The call to the \texttt{smuggle()} function carries out
\texttt{davos}'s central logic by determining whether the smuggled
package must be installed, carrying out the installation if necessary,
and subsequently loading it into the namespace. This process is
outlined in Figure~\ref{fig:flow-chart}. Because the
\texttt{smuggle()} function is defined in the notebook namespace, it
is also possible (though never necessary) to call it
directly. Deactivating \texttt{davos} will delete the name
``\texttt{smuggle}'' from the namespace, unless its value has been
overwritten and no longer refers to the \texttt{smuggle()}
function. It will also deregister the \texttt{davos} parser from the
set of input transformers run when each notebook cell is
executed. While the overhead added by the \texttt{davos} parser is
minimal, this may be useful, for example, when optimizing or precisely
profiling code.

\begin{figure}[tp]
\centering
\includegraphics[width=\textwidth]{figs/flow_chart}
\caption{\small \textbf{\texttt{smuggle()} function algorithm.}  At a
  high level, the \texttt{smuggle()} function may be conceptualized as
following two basic steps.  First (left), \texttt{davos} ensures that the
correct version of the desired package has been installed, carrying
out the installation automatically if needed.  Second (right),
\texttt{davos} imports the package and updates the current runtime environment.}
\label{fig:flow-chart}
\end{figure}


\section{Illustrative Example}\label{sec:illustrative-example}

Across different versions of a given package, particular modules, functions, and other objects 
may be updated, removed, renamed, or otherwise altered in some manner.  In addition to changing the
behaviors of active computations, these changes can render saved objects created using one
version of a package incompatible with other versions of the
same package.  For example, the popular \texttt{pandas}~\cite{McKi10}
library used to include the \texttt{Panel} data structure for storing 3-dimensional arrays.  
Since version 0.20.0, however, the \texttt{Panel} class has been deprecated, and in 
version 0.25.0, it was removed entirely. If a user had a dataset stored in a \texttt{Panel} object
(created using an older version of \texttt{pandas}) and saved it to their disk (e.g., for later reuse
or to share with other users) by serializing the \texttt{Panel} with Python's \texttt{pickle} protocol, 
that dataset could not be read by any version of \texttt{pandas} from 0.25.0 or beyond. These
incompatibilities are also not limited solely to traditional forms of data.
For example, saved model states and other objects may reference
modules, functions, attributes, classes, or other objects that may not be identical (or even present)
across all versions of their associated package.

\begin{figure}[tp]
\centering
\includegraphics[width=\textwidth]{figs/illustrative_example}
\caption{\small \textbf{Example use case for \texttt{davos}.}
  Snippets from this example are also excerpted in the main text of
  Section~\ref{sec:illustrative-example}.}
\label{fig:illustrative-example}
\end{figure}

The example provided in Figure~\ref{fig:illustrative-example}
demonstrates how the \texttt{davos} package can be used to circumvent
these incompatibilities by carefully controlling which versions of
each package are used in different parts of the notebook.  The example
shows how a dataset and model that require now-incompatible components of
the \texttt{pandas} and \texttt{scikit-learn}~\cite{PedrEtal11}
packages may be loaded in (using older versions of each package) and used
alongside more recent versions of each package that provide new and improved functionality.
When included at the top of a Jupyter notebook, the code in Figure~\ref{fig:illustrative-example}
ensures that these objects will be loaded successfully and analyzed using the same set
of package versions, no matter when or by whom the notebook is run.

After installing and importing \texttt{davos} (lines 1--2), we first smuggle two
utilities for interacting with local files in the code below. The
\texttt{smuggle} statement in line 4 loads the \texttt{is\_file()}
function from the Python standard library's \texttt{os.path}
module. Standard library modules are included with all Python
distributions, so this line is functionally equivalent to an
\texttt{import} statement and does not need or benefit from an onion
comment. Line 5 loads the \texttt{joblib} package~\cite{Varo10},
installing it first, if necessary. Since \texttt{joblib}'s I/O
interface has historically remained stable and backwards-compatible
across releases, requiring that users have a particular exact version
installed would likely be unnecessarily restrictive. However, a
\textit{future} release might introduce some breaking change.  The
onion comment in line 5 helps ensure the analysis notebook continues
to run properly in the future by limiting allowable versions to those
already released when the code was written:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example1}
\end{center}
Line 7 then uses the \texttt{davos.config} object to enable
\texttt{davos}'s \texttt{auto\_rerun} option before smuggling the next
two packages: \texttt{NumPy}~\cite{HarrEtal20} and
\texttt{pandas}. Because these packages rely heavily on custom C data
types, loading the particular versions from the onion comments may
require restarting the notebook kernel if different versions had been previously
imported during the same interpreter session (see
Sec.~\ref{subsec:config}).
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example2}
\end{center}
Setting the \texttt{auto\_rerun} attribute to \texttt{True} is particularly useful
for managing the installation of \texttt{pandas} in the next
lines:
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example3}
\end{center}
If we suppose that the data contained in \texttt{data-old.pkl} is
stored in a \texttt{Panel} object, then we must use a version of 
\texttt{pandas} prior to 0.25.0 (i.e., the version in which the \texttt{Panel} 
class was removed) to be able to load it in. Line 11 ensures
that an older version of \texttt{pandas} will be imported, enabling
the data to be read in (and, in line 13, written to a CSV
file, which is compatible with newer versions of \texttt{pandas}).

Newer versions of \texttt{pandas} have brought substantial
improvements including better performance, bug fixes, and additional functionality.
Although the original dataset had to be read in using an older version
of the package, we can take advantage of these more recent updates 
by smuggling \texttt{pandas} a second time on line 15 (whose onion comment
specifies that version 1.3.5 should be installed and loaded).  Since
a different version of \texttt{pandas} had already been loaded by the Python interpreter
(on line 11), the notebook kernel must be restarted in order to replace the old 
version's custom C extensions with those from the new version.  The \texttt{auto\_rerun} flag
set on line 7 enables \texttt{davos} to trigger this process automatically so that
the code can continue running without user intervention, and converting
the dataset to a CSV file in lines 10--13 ensures that
the older version of \texttt{pandas} does not need to be reinstalled.

Next, line 17 uses the \texttt{davos.configure()} function to disable
the \texttt{auto\_rerun} option and simultaneously enable two other
options: \texttt{suppress\_stdout} and \texttt{noninteractive}. With
these options enabled, lines 18--19 \texttt{smuggle}
\texttt{TensorFlow}~\cite{AbadEtal15}, a powerful end-to-end platform
for building and working with machine learning models, and
\texttt{UMAP}~\cite{McInEtal18b}, a package that implements a family
of related manifold learning techniques. The onion comment in line 19
also specifies that \texttt{UMAP} should be installed with the
optional requirements needed for its ``plot'' and ``parametric\_umap''
features. Together, these two packages depend on 36 other unique
packages, most of which have dependencies of their own. And if many of
these are not already installed in the user's environment, lines
18--19 could take several minutes to run.  Enabling the
\texttt{noninteractive} option ensures that the installation will
continue automatically without user input during that time.  Enabling
\texttt{suppress\_stdout} also suppresses console outputs while installing 
these packages and their many dependencies to prevent other potentially important outputs from being buried.
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example4}
\end{center}

After re-enabling these two options (line 20), we next smuggle
specific versions of three plotting packages:
\texttt{Matplotlib}~\cite{Hunt07}, \texttt{seaborn}~\cite{Wask21}, and
\texttt{Quail}~\cite{HeusEtal17} (lines 22--24). Because the first two
are requirements of \texttt{UMAP}'s optional ``plot'' feature, they
will have already been installed by line 19, though possibly as
different versions than those specified in the onion comments on lines
22 and 23. If the installed and specified versions are the same, these
\texttt{smuggle} statements will function like standard \texttt{import}
statements to load the packages into the notebook namespace. If they
differ, \texttt{davos} will download the requested versions in place
of the installed versions before doing so.
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example5}
\end{center}
Line 24 uses an onion comment to specify that \texttt{Quail} should be
installed directly from a specific GitHub commit (\texttt{6c847a4}).
This ability to load packages directly from GitHub repositories can
enable developers to more easily use forked or modified versions of other
packages in their notebooks, even if those versions have not been
officially released.

In lines 26--29, we demonstrate another aspect of \texttt{davos}'s
functionality that supports more advanced installation scenarios.  The
\texttt{ipywidgets}~\cite{FredEtal15} package provides an API for
creating various JavaScript widgets with Python code, and the \texttt{widgetsnbextension} package provides
the machinery needed by the notebook frontend to display them.
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example6}
\end{center}
A complication is that \texttt{ipywidgets} must be installed in the
same environment as the IPython kernel, whereas
\texttt{widgetsnbextension} must be installed in the environment that
houses the Jupyter notebook server. In many basic setups, these two
environments are the same.  However, a common ``advanced'' approach
entails running the notebook server from a base environment, with
additional environments each providing their own separate,
interchangeable IPython kernels.  To accomodate this multi-environment
scenario, on lines 26 and 28, we use the \texttt{pip\_executable} option to control which environments each
package should be installed to.  Once these two packages are installed
and imported, line 30 smuggles \texttt{tqdm}~\cite{daCoEtal22}, which
display progress bars to provide status updates for running code. In
Jupyter notebooks, the \texttt{tqdm.notebook} module can be imported
to enable more aesthetically pleasing progress bars that are displayed via
\texttt{ipywidgets}, if that package is installed and
importable. Therefore, to take advantage of this feature, it was
important to \texttt{smuggle} \texttt{tqdm} after ensuring the
\texttt{ipywidgets} package was available.

Next, we load in the reformatted dataset (line 33) and pre-trained
model (line 35) that we wish to use in our analysis.  In our
hypothetical example, we can suppose that the model was provided as a
\texttt{scikit-learn} \texttt{Pipeline} object that passes data
through two pretrained models in succession.  First, a trained \texttt{CountVectorizer}
instance converts text data to an array of word counts.  Second, the
word counts are passed to a topic model~\cite{BleiEtal03} using a
pretrained \texttt{LatentDirichletAllocation} instance.
\begin{center}
\includegraphics[width=0.9\textwidth]{figs/example7}
\end{center}
Let us suppose that the \texttt{Pipeline} object had been saved by its
original creator using the \texttt{joblib} package, as
\texttt{scikit-learn}'s documentation recommends.  Because
\texttt{joblib} uses the \texttt{pickle} protocol internally, the
ability to save and load pre-trained models is not guaranteed across
different \texttt{scikit-learn} versions.  For example, suppose that
the \texttt{Pipeline} object was created using \texttt{scikit-learn}
v0.21.3.  In that version of \texttt{scikit-learn}, the
\texttt{LatentDirichletAllocation} class was defined in
\texttt{sklearn.decomposition.online\_lda}.  However, in version
0.22.0, that module was renamed to \texttt{\_online\_lda}, and in
version 0.22.1, it was again renamed to \texttt{\_lda}.

In order to correctly load the model that includes the pre-trained
\texttt{LatentDirichlet\-Allocation} instance, in line 34, we first
\texttt{smuggle} a version of \texttt{scikit-learn} prior to v0.22.0 (i.e.,
before the first time the relevant module's name was changed).  Once
the model is loaded and reconstructed in memory from a compatible
package version (line 35), we upgrade to a newer version of
\texttt{scikit-learn} in line 36.  Taken together, the code in
Figure~\ref{fig:illustrative-example} shows how \texttt{davos} can
enable users to load in data and models that are incompatible with
newer versions of \texttt{pandas} and \texttt{scikit-learn}, but still
\textit{analyze} and manipulate the data and model output using the
latest approaches and implementations.


\section{Impact}

Like virtual environments, containers, and virtual machines, the
\texttt{davos} package (when used in conjunction with Jupyter
notebooks) provides a light\-weight mechanism for sharing code and
ensuring reproducibility across users and computing environments
(Fig.~\ref{fig:code-sharing}). Further, \texttt{davos} enables users
to fully specify (and install, as needed) any project dependencies
within the same notebook. This provides a system whereby executable
code (along with text and media) \textit{and} code for setting up and
configuring the project dependencies, may be combined within a single
notebook file.

We designed \texttt{davos} for use in research applications. For
example, in many settings, \texttt{davos} may be used as a drop-in
replacement for more-difficult-to-set-up virtual environments,
containers, and/or virtual machines. For researchers, this lowers
barriers to sharing code. By eliminating most of the setup costs of
reconstructing the original researchers' computing environment,
\texttt{davos} also lowers barriers to entry for members of the
scientific community and the public who seek to run shared code.

Beyond research applications, \texttt{davos} is also useful in
pedagogical settings. For example, in programming courses, instructors
and students may use the \texttt{davos} package to ensure their
notebooks will run correctly on others' machines. When combined with
online notebook-based platforms like Google Colaboratory,
\texttt{davos} provides a convenient way to manage dependencies within
a notebook, without requiring any software (beyond a web browser) to
be installed on the students' or instructors' systems. For the same
reasons, \texttt{davos} also provides an elegant means of sharing
ready-to-run notebook-based demonstrations or tutorials that install
their dependencies automatically.

Since its initial release, \texttt{davos} has found use in a variety
of applications. In addition to managing computing environments for
multiple ongoing research studies, \texttt{davos} is being used by
both students and instructors in programming and methods courses such
as Storytelling with Data~\cite{Mann21d} (an open course on data
science, visualization, and communication) and Laboratory in
Psychological Science~\cite{Mann22} (an open course on experimental
and statistical methods for psychology research) to simplify
distributing lessons and submitting assignments, as well as in online
demos such as \texttt{abstract2paper}~\cite{Mann21e} (an example
application of GPT-Neo~\cite{GaoEtal20, BlacEtal21}) to share
ready-to-run code that installs dependencies automatically.

Our work also has several more subtle ``advanced'' use cases and
potential impacts. Whereas Python's built-in \texttt{import} statement
is agnostic to packages' version information, \texttt{smuggle}
statements (when combined with onion comments) are version-sensitive.
And because onion comments are parsed at runtime, required packages
and their specified versions are installed in a just-in-time
manner. Thus, it is possible in most cases to \texttt{smuggle} a
specific package version or revision even if a different version has
already been loaded. This enables more complex uses that take
advantage of multiple versions of a package within a single
interpreter session (e.g., see
Sec.~\ref{sec:illustrative-example} and Fig.~\ref{fig:illustrative-example}). This could be useful in cases
where specific features are added or removed from a package across
different versions, or in comparing the performance or functionality
of particular features across different versions of the same package.

A second more subtle impact of our work is in providing a
proof-of-concept of how the ability to add new ``keyword-like''
operators to the Python language could be specifically useful to
researchers. With \texttt{davos}, we accomplish this by leveraging
IPython notebooks' internal code parsing and execution machinery. We
note that, while other popular packages similarly use these mechanisms
to providing notebook-specific functionality (e.g.,
\cite{Hunt07,HeusEtal18a}), this approach also has the potential to be
exploited for more nefarious purposes. For example, a malicious user
could design a Python package that, when imported, substantially
changes the notebook's functionality by adding new \textit{unexpected}
keyword-like objects (e.g., based around common typos). We also note
that this implementation approach means \texttt{davos}'s functionality
is currently restricted to IPython notebook environments. However,
there have been early-stage discussions of providing this sort of
syntactic customizability as a core feature of the Python language,
including a draft proposal~\cite{Shan20}. In addition to enabling
\texttt{davos} to be extended for use outside of notebooks, this could
lead to exciting new tools that, like \texttt{davos}, extend the
Python language in useful and more secure ways.


\section{Conclusions}

The \texttt{davos} package supports reproducible research by providing
a novel lightweight system for sharing notebook-based code. But
perhaps the most exciting uses of the \texttt{davos} package are those
that we have \textit{not} yet considered or imagined. We hope that the
Python community will find \texttt{davos} to provide a convenient
means of managing project dependencies to facilitate code sharing. We
also hope that some of the more advanced applications of our package
might lead to new insights or discoveries.


\section*{Author Contributions}

\textbf{Paxton C. Fitzpatrick}: Conceptualization, Methodology,
Software, Validation, Writing - Original Draft,
Visualization. \textbf{Jeremy R. Manning}: Conceptualization,
Resources, Validation, Writing - Review \& Editing, Supervision,
Funding acquisition.

\section*{Funding}

Our work was supported in part by NSF grant number 2145172 to JRM.
The content is solely the responsibility of the authors and does not
necessarily represent the official views of our supporting
organizations.


\section*{Declaration of Competing Interest}

We wish to confirm that there are no known conflicts of interest
associated with this publication and there has been no significant
financial support for this work that could have influenced its
outcome.


\section*{Acknowledgements}

We acknowledge useful feedback and discussion from the students of
JRM's \textit{Storytelling with Data} course (Winter, 2022 offering)
who used preliminary versions of our package in several assignments.

\bibliographystyle{elsarticle-num}
\bibliography{CDL-bibliography/cdl}

\end{document}

